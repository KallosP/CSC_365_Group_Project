import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np
import random
import pytz

def database_connection_url():
    dotenv.load_dotenv()
    DB_USER: str = os.environ.get("POSTGRES_USER")
    DB_PASSWD = os.environ.get("POSTGRES_PASSWORD")
    DB_SERVER: str = os.environ.get("POSTGRES_SERVER")
    DB_PORT: str = os.environ.get("POSTGRES_PORT")
    DB_NAME: str = os.environ.get("POSTGRES_DB")
    return f"postgresql://{DB_USER}:{DB_PASSWD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS subtasks;
    DROP TABLE IF EXISTS tags;
    DROP TABLE IF EXISTS tasks;
    DROP TABLE IF EXISTS users;

    create table
    public.users (
        user_id bigint generated by default as identity,
        user_name text null default ''::text,
        password text null default ''::text,
        free_time time without time zone [] null,
        constraint users_pkey primary key (user_id)
    ) tablespace pg_default;

    create table
    public.tasks (
        task_id integer generated by default as identity,
        name text null default ''::text,
        description text null default ''::text,
        priority text null default ''::text,
        status text null default ''::text,
        start_date timestamp with time zone null,
        due_date timestamp with time zone null,
        end_date timestamp with time zone null,
        user_id bigint null,
        estimated_time bigint null,
        constraint tasks_pkey primary key (task_id),
        constraint tasks_user_id_fkey foreign key (user_id) references users (user_id)
    ) tablespace pg_default;

    create table
    public.subtasks (
        subtask_id serial,
        task_id integer null,
        name text null,
        priority text null,
        due_date timestamp with time zone null,
        estimated_time integer null,
        weight integer null,
        user_id integer null,
        constraint subtasks_pkey primary key (subtask_id),
        constraint subtasks_task_id_fkey foreign key (task_id) references tasks (task_id),
        constraint subtasks_user_id_fkey foreign key (user_id) references users (user_id)
    ) tablespace pg_default;

    create table
    public.tags (
        tag_id bigint generated by default as identity,
        name text null default ''::text,
        user_id bigint null,
        task_id integer null,
        constraint tags_pkey primary key (tag_id),
        constraint tags_task_id_fkey foreign key (task_id) references tasks (task_id) on delete cascade,
        constraint tags_user_id_fkey foreign key (user_id) references users (user_id)
    ) tablespace pg_default;

    """))
    
num_users = 100
fake = Faker()
tasks_sample_distribution = np.random.default_rng().negative_binomial(0.04, 0.01, num_users)
#category_sample_distribution = np.random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
#                                                 num_users,
#                                                p=[0.1, 0.05, 0.1, 0.3, 0.05, 0.05, 0.05, 0.05, 0.15, 0.1])
total_tasks = 0

# create fake posters with fake names and birthdays
with engine.begin() as conn:
    print("creating fake posters...")
    tasks = []
    for i in range(num_users):
        if (i % 10 == 0):
            print(i)
        
        name = fake.name()

        user_id = conn.execute(sqlalchemy.text("""
        INSERT INTO users (user_name) VALUES (:username) RETURNING user_id;
        """), {"username": name}).scalar_one()

        num_tasks = tasks_sample_distribution[i]
        #likes_sample_distribution = np.random.default_rng().negative_binomial(0.8, 0.0001, num_tasks)  
        for j in range(num_tasks):
            total_tasks += 1
            tasks.append({
                "name": fake.bs(),
                "description": fake.sentences(),
                "priority": "low",
                "status": "not started",
                "start_date": fake.date_time_between(start_date='-5y', end_date='now', tzinfo=pytz.timezone(fake.timezone())),
                "due_date": fake.date_time_between(start_date='-5y', end_date='now', tzinfo=pytz.timezone(fake.timezone())),
                "end_date": fake.date_time_between(start_date='-5y', end_date='now', tzinfo=pytz.timezone(fake.timezone())),
                "estimated_time": random.randint(1, 30)
            })

    if tasks:
        conn.execute(sqlalchemy.text("""
        INSERT INTO tasks (name, description, priority, status, start_date, due_date, end_date, estimated_time) 
        VALUES (:name, :description, :priority, :status, :start_date, :due_date, :end_date, :estimated_time);
        """), tasks)

    print("total tasks: ", total_tasks)